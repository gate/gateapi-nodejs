/**
 * Gate API
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { InlineObject1 } from '../model/inlineObject1';
import { InlineObject2 } from '../model/inlineObject2';
import { InlineObject3 } from '../model/inlineObject3';
import { InlineObject4 } from '../model/inlineObject4';
import { InlineResponse2002 } from '../model/inlineResponse2002';
import { InlineResponse2003 } from '../model/inlineResponse2003';
import { InlineResponse2004 } from '../model/inlineResponse2004';
import { InlineResponse2005 } from '../model/inlineResponse2005';
import { InlineResponse2006 } from '../model/inlineResponse2006';
import { InlineResponse2007 } from '../model/inlineResponse2007';
import { InlineResponse2008 } from '../model/inlineResponse2008';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class OTCApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     * Create fiat and stablecoin quotes, supporting both PAY and GET directions
     * @summary Fiat and stablecoin quote
     * @param inlineObject1
     */
    public async createOtcQuote(
        inlineObject1: InlineObject1,
    ): Promise<{ response: AxiosResponse; body: InlineResponse2002 }> {
        const localVarPath = this.client.basePath + '/otc/quote';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'inlineObject1' is not null or undefined
        if (inlineObject1 === null || inlineObject1 === undefined) {
            throw new Error('Required parameter inlineObject1 was null or undefined when calling createOtcQuote.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(inlineObject1, 'InlineObject1'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<InlineResponse2002>(config, 'InlineResponse2002', authSettings);
    }

    /**
     * Create a fiat order, supporting BUY for on-ramp and SELL for off-ramp
     * @summary Create fiat order
     * @param inlineObject2
     */
    public async createOtcOrder(
        inlineObject2: InlineObject2,
    ): Promise<{ response: AxiosResponse; body: InlineResponse2003 }> {
        const localVarPath = this.client.basePath + '/otc/order/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'inlineObject2' is not null or undefined
        if (inlineObject2 === null || inlineObject2 === undefined) {
            throw new Error('Required parameter inlineObject2 was null or undefined when calling createOtcOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(inlineObject2, 'InlineObject2'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<InlineResponse2003>(config, 'InlineResponse2003', authSettings);
    }

    /**
     * Create stablecoin order
     * @summary Create stablecoin order
     * @param inlineObject3
     */
    public async createStableCoinOrder(
        inlineObject3: InlineObject3,
    ): Promise<{ response: AxiosResponse; body: InlineResponse2004 }> {
        const localVarPath = this.client.basePath + '/otc/stable_coin/order/create';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'inlineObject3' is not null or undefined
        if (inlineObject3 === null || inlineObject3 === undefined) {
            throw new Error(
                'Required parameter inlineObject3 was null or undefined when calling createStableCoinOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(inlineObject3, 'InlineObject3'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<InlineResponse2004>(config, 'InlineResponse2004', authSettings);
    }

    /**
     * Get user\'s default bank account information for order placement
     * @summary Get user\'s default bank account information
     */
    public async getUserDefaultBank(): Promise<{ response: AxiosResponse; body: InlineResponse2005 }> {
        const localVarPath = this.client.basePath + '/otc/get_user_def_bank';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<InlineResponse2005>(config, 'InlineResponse2005', authSettings);
    }

    /**
     * Mark fiat order as paid
     * @summary Mark fiat order as paid
     * @param inlineObject4
     */
    public async markOtcOrderPaid(
        inlineObject4: InlineObject4,
    ): Promise<{ response: AxiosResponse; body: InlineResponse2003 }> {
        const localVarPath = this.client.basePath + '/otc/order/paid';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'inlineObject4' is not null or undefined
        if (inlineObject4 === null || inlineObject4 === undefined) {
            throw new Error('Required parameter inlineObject4 was null or undefined when calling markOtcOrderPaid.');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(inlineObject4, 'InlineObject4'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<InlineResponse2003>(config, 'InlineResponse2003', authSettings);
    }

    /**
     * Cancel fiat order
     * @summary Fiat order cancellation
     * @param orderId Order ID
     */
    public async cancelOtcOrder(orderId: string): Promise<{ response: AxiosResponse; body: InlineResponse2003 }> {
        const localVarPath = this.client.basePath + '/otc/order/cancel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelOtcOrder.');
        }

        let orderIdSerialized = ObjectSerializer.serialize(orderId, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(orderIdSerialized)) {
            orderIdSerialized = orderIdSerialized.join(',');
        }
        localVarQueryParameters['order_id'] = orderIdSerialized;

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<InlineResponse2003>(config, 'InlineResponse2003', authSettings);
    }

    /**
     * Query the fiat order list with filters such as type, currency, time range, and status
     * @summary Fiat order list
     * @param opts Optional parameters
     * @param opts.type BUY for on-ramp, SELL for off-ramp
     * @param opts.fiatCurrency Fiat currency
     * @param opts.cryptoCurrency Digital currency
     * @param opts.startTime starttime   for example : 2025-09-09
     * @param opts.endTime endtime  for example :2025-09-09
     * @param opts.status DONE ：完成 CANCEL  ：取消 PROCESSING ：进行中
     * @param opts.pn Page number
     * @param opts.ps Number of items per page
     */
    public async listOtcOrders(opts: {
        type?: string;
        fiatCurrency?: string;
        cryptoCurrency?: string;
        startTime?: string;
        endTime?: string;
        status?: string;
        pn?: string;
        ps?: string;
    }): Promise<{ response: AxiosResponse; body: InlineResponse2006 }> {
        const localVarPath = this.client.basePath + '/otc/order/list';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.type !== undefined) {
            let typeSerialized = ObjectSerializer.serialize(opts.type, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(typeSerialized)) {
                typeSerialized = typeSerialized.join(',');
            }
            localVarQueryParameters['type'] = typeSerialized;
        }

        if (opts.fiatCurrency !== undefined) {
            let fiatCurrencySerialized = ObjectSerializer.serialize(opts.fiatCurrency, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fiatCurrencySerialized)) {
                fiatCurrencySerialized = fiatCurrencySerialized.join(',');
            }
            localVarQueryParameters['fiat_currency'] = fiatCurrencySerialized;
        }

        if (opts.cryptoCurrency !== undefined) {
            let cryptoCurrencySerialized = ObjectSerializer.serialize(opts.cryptoCurrency, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(cryptoCurrencySerialized)) {
                cryptoCurrencySerialized = cryptoCurrencySerialized.join(',');
            }
            localVarQueryParameters['crypto_currency'] = cryptoCurrencySerialized;
        }

        if (opts.startTime !== undefined) {
            let startTimeSerialized = ObjectSerializer.serialize(opts.startTime, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(startTimeSerialized)) {
                startTimeSerialized = startTimeSerialized.join(',');
            }
            localVarQueryParameters['start_time'] = startTimeSerialized;
        }

        if (opts.endTime !== undefined) {
            let endTimeSerialized = ObjectSerializer.serialize(opts.endTime, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(endTimeSerialized)) {
                endTimeSerialized = endTimeSerialized.join(',');
            }
            localVarQueryParameters['end_time'] = endTimeSerialized;
        }

        if (opts.status !== undefined) {
            let statusSerialized = ObjectSerializer.serialize(opts.status, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(statusSerialized)) {
                statusSerialized = statusSerialized.join(',');
            }
            localVarQueryParameters['status'] = statusSerialized;
        }

        if (opts.pn !== undefined) {
            let pnSerialized = ObjectSerializer.serialize(opts.pn, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(pnSerialized)) {
                pnSerialized = pnSerialized.join(',');
            }
            localVarQueryParameters['pn'] = pnSerialized;
        }

        if (opts.ps !== undefined) {
            let psSerialized = ObjectSerializer.serialize(opts.ps, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(psSerialized)) {
                psSerialized = psSerialized.join(',');
            }
            localVarQueryParameters['ps'] = psSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<InlineResponse2006>(config, 'InlineResponse2006', authSettings);
    }

    /**
     * Query stablecoin order list with filtering by currency, time range, status, etc.
     * @summary Stablecoin order list
     * @param opts Optional parameters
     * @param opts.pageSize Number of records per page
     * @param opts.pageNumber Page number
     * @param opts.coinName ordercurrency
     * @param opts.startTime Start Time
     * @param opts.endTime End time
     * @param opts.status Status: PROCESSING: in progress / DONE：completed / FAILED: failed
     */
    public async listStableCoinOrders(opts: {
        pageSize?: string;
        pageNumber?: string;
        coinName?: string;
        startTime?: string;
        endTime?: string;
        status?: string;
    }): Promise<{ response: AxiosResponse; body: InlineResponse2007 }> {
        const localVarPath = this.client.basePath + '/otc/stable_coin/order/list';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        opts = opts || {};
        if (opts.pageSize !== undefined) {
            let pageSizeSerialized = ObjectSerializer.serialize(opts.pageSize, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(pageSizeSerialized)) {
                pageSizeSerialized = pageSizeSerialized.join(',');
            }
            localVarQueryParameters['page_size'] = pageSizeSerialized;
        }

        if (opts.pageNumber !== undefined) {
            let pageNumberSerialized = ObjectSerializer.serialize(opts.pageNumber, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(pageNumberSerialized)) {
                pageNumberSerialized = pageNumberSerialized.join(',');
            }
            localVarQueryParameters['page_number'] = pageNumberSerialized;
        }

        if (opts.coinName !== undefined) {
            let coinNameSerialized = ObjectSerializer.serialize(opts.coinName, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(coinNameSerialized)) {
                coinNameSerialized = coinNameSerialized.join(',');
            }
            localVarQueryParameters['coin_name'] = coinNameSerialized;
        }

        if (opts.startTime !== undefined) {
            let startTimeSerialized = ObjectSerializer.serialize(opts.startTime, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(startTimeSerialized)) {
                startTimeSerialized = startTimeSerialized.join(',');
            }
            localVarQueryParameters['start_time'] = startTimeSerialized;
        }

        if (opts.endTime !== undefined) {
            let endTimeSerialized = ObjectSerializer.serialize(opts.endTime, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(endTimeSerialized)) {
                endTimeSerialized = endTimeSerialized.join(',');
            }
            localVarQueryParameters['end_time'] = endTimeSerialized;
        }

        if (opts.status !== undefined) {
            let statusSerialized = ObjectSerializer.serialize(opts.status, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(statusSerialized)) {
                statusSerialized = statusSerialized.join(',');
            }
            localVarQueryParameters['status'] = statusSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<InlineResponse2007>(config, 'InlineResponse2007', authSettings);
    }

    /**
     * Query fiat order details
     * @summary Fiat order details
     * @param orderId Order ID
     */
    public async getOtcOrderDetail(orderId: string): Promise<{ response: AxiosResponse; body: InlineResponse2008 }> {
        const localVarPath = this.client.basePath + '/otc/order/detail';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getOtcOrderDetail.');
        }

        let orderIdSerialized = ObjectSerializer.serialize(orderId, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(orderIdSerialized)) {
            orderIdSerialized = orderIdSerialized.join(',');
        }
        localVarQueryParameters['order_id'] = orderIdSerialized;

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<InlineResponse2008>(config, 'InlineResponse2008', authSettings);
    }
}
