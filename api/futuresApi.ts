/**
 * Gate API
 * Welcome to Gate API APIv4 provides operations related to spot, margin, and contract trading, including public interfaces for querying market data and authenticated private interfaces for implementing API-based automated trading.
 *
 * Contact: support@mail.gate.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-locals */
import { BatchAmendOrderReq } from '../model/batchAmendOrderReq';
import { BatchFuturesOrder } from '../model/batchFuturesOrder';
import { Contract } from '../model/contract';
import { ContractStat } from '../model/contractStat';
import { CountdownCancelAllFuturesTask } from '../model/countdownCancelAllFuturesTask';
import { FundingRateRecord } from '../model/fundingRateRecord';
import { FutureCancelOrderResult } from '../model/futureCancelOrderResult';
import { FuturesAccount } from '../model/futuresAccount';
import { FuturesAccountBook } from '../model/futuresAccountBook';
import { FuturesAutoDeleverage } from '../model/futuresAutoDeleverage';
import { FuturesBBOOrder } from '../model/futuresBBOOrder';
import { FuturesCandlestick } from '../model/futuresCandlestick';
import { FuturesFee } from '../model/futuresFee';
import { FuturesIndexConstituents } from '../model/futuresIndexConstituents';
import { FuturesLeverage } from '../model/futuresLeverage';
import { FuturesLimitRiskTiers } from '../model/futuresLimitRiskTiers';
import { FuturesLiqOrder } from '../model/futuresLiqOrder';
import { FuturesLiquidate } from '../model/futuresLiquidate';
import { FuturesOrder } from '../model/futuresOrder';
import { FuturesOrderAmendment } from '../model/futuresOrderAmendment';
import { FuturesOrderBook } from '../model/futuresOrderBook';
import { FuturesPositionCrossMode } from '../model/futuresPositionCrossMode';
import { FuturesPremiumIndex } from '../model/futuresPremiumIndex';
import { FuturesPriceTriggeredOrder } from '../model/futuresPriceTriggeredOrder';
import { FuturesRiskLimitTier } from '../model/futuresRiskLimitTier';
import { FuturesTicker } from '../model/futuresTicker';
import { FuturesTrade } from '../model/futuresTrade';
import { FuturesUpdatePriceTriggeredOrder } from '../model/futuresUpdatePriceTriggeredOrder';
import { InlineObject } from '../model/inlineObject';
import { InsuranceRecord } from '../model/insuranceRecord';
import { MyFuturesTrade } from '../model/myFuturesTrade';
import { MyFuturesTradeTimeRange } from '../model/myFuturesTradeTimeRange';
import { Position } from '../model/position';
import { PositionClose } from '../model/positionClose';
import { TriggerOrderResponse } from '../model/triggerOrderResponse';
import { TriggerTime } from '../model/triggerTime';
import { ObjectSerializer } from '../model/models';
import { ApiClient } from './apiClient';
import { AxiosRequestConfig, AxiosResponse } from 'axios';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export class FuturesApi {
    protected client: ApiClient;

    constructor(client?: ApiClient) {
        if (client) {
            this.client = client;
        } else {
            this.client = new ApiClient();
        }
    }

    /**
     *
     * @summary Query all futures contracts
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listFuturesContracts(
        settle: 'btc' | 'usdt',
        opts: { limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<Contract> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/contracts'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesContracts.');
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<Contract>>(config, 'Array<Contract>', authSettings);
    }

    /**
     *
     * @summary Query single contract information
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getFuturesContract(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Contract }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/contracts/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getFuturesContract.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getFuturesContract.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Contract>(config, 'Contract', authSettings);
    }

    /**
     * Bids will be sorted by price from high to low, while asks sorted reversely
     * @summary Query futures market depth information
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.interval Price precision for depth aggregation, 0 means no aggregation, defaults to 0 if not specified
     * @param opts.limit Number of depth levels
     * @param opts.withId Whether to return depth update ID. This ID increments by 1 each time the depth changes
     */
    public async listFuturesOrderBook(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { interval?: string; limit?: number; withId?: boolean },
    ): Promise<{ response: AxiosResponse; body: FuturesOrderBook }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/order_book'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesOrderBook.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesOrderBook.');
        }

        opts = opts || {};
        let contractSerialized = ObjectSerializer.serialize(contract, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(contractSerialized)) {
            contractSerialized = contractSerialized.join(',');
        }
        localVarQueryParameters['contract'] = contractSerialized;

        if (opts.interval !== undefined) {
            let intervalSerialized = ObjectSerializer.serialize(opts.interval, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(intervalSerialized)) {
                intervalSerialized = intervalSerialized.join(',');
            }
            localVarQueryParameters['interval'] = intervalSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.withId !== undefined) {
            let withIdSerialized = ObjectSerializer.serialize(opts.withId, 'boolean');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(withIdSerialized)) {
                withIdSerialized = withIdSerialized.join(',');
            }
            localVarQueryParameters['with_id'] = withIdSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<FuturesOrderBook>(config, 'FuturesOrderBook', authSettings);
    }

    /**
     *
     * @summary Futures market transaction records
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. Use &#x60;from&#x60; and &#x60;to&#x60; instead to limit time range
     * @param opts.from Specify starting time in Unix seconds. If not specified, &#x60;to&#x60; and &#x60;limit&#x60; will be used to limit response items. If items between &#x60;from&#x60; and &#x60;to&#x60; are more than &#x60;limit&#x60;, only &#x60;limit&#x60; number will be returned.
     * @param opts.to Specify end time in Unix seconds, default to current time.
     */
    public async listFuturesTrades(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { limit?: number; offset?: number; lastId?: string; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesTrade> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/trades'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesTrades.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesTrades.');
        }

        opts = opts || {};
        let contractSerialized = ObjectSerializer.serialize(contract, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(contractSerialized)) {
            contractSerialized = contractSerialized.join(',');
        }
        localVarQueryParameters['contract'] = contractSerialized;

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        if (opts.lastId !== undefined) {
            let lastIdSerialized = ObjectSerializer.serialize(opts.lastId, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(lastIdSerialized)) {
                lastIdSerialized = lastIdSerialized.join(',');
            }
            localVarQueryParameters['last_id'] = lastIdSerialized;
        }

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesTrade>>(config, 'Array<FuturesTrade>', authSettings);
    }

    /**
     * Return specified contract candlesticks. If prefix `contract` with `mark_`, the contract\'s mark price candlesticks are returned; if prefix with `index_`, index price candlesticks will be returned.  Maximum of 2000 points are returned in one query. Be sure not to exceed the limit when specifying `from`, `to` and `interval`
     * @summary Futures market K-line chart
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified
     * @param opts.to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision
     * @param opts.limit Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected.
     * @param opts.interval Interval time between data points. Note that &#x60;1w&#x60; means natural week(Mon-Sun), while &#x60;7d&#x60; means every 7d since unix 0. 30d represents a natural month, not 30 days
     * @param opts.timezone Time zone: all/utc0/utc8, default utc0
     */
    public async listFuturesCandlesticks(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: {
            from?: number;
            to?: number;
            limit?: number;
            interval?: '10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d';
            timezone?: string;
        },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesCandlestick> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/candlesticks'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesCandlesticks.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesCandlesticks.');
        }

        opts = opts || {};
        let contractSerialized = ObjectSerializer.serialize(contract, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(contractSerialized)) {
            contractSerialized = contractSerialized.join(',');
        }
        localVarQueryParameters['contract'] = contractSerialized;

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.interval !== undefined) {
            let intervalSerialized = ObjectSerializer.serialize(
                opts.interval,
                "'10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d'",
            );
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(intervalSerialized)) {
                intervalSerialized = intervalSerialized.join(',');
            }
            localVarQueryParameters['interval'] = intervalSerialized;
        }

        if (opts.timezone !== undefined) {
            let timezoneSerialized = ObjectSerializer.serialize(opts.timezone, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(timezoneSerialized)) {
                timezoneSerialized = timezoneSerialized.join(',');
            }
            localVarQueryParameters['timezone'] = timezoneSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesCandlestick>>(config, 'Array<FuturesCandlestick>', authSettings);
    }

    /**
     * Maximum of 1000 points can be returned in a query. Be sure not to exceed the limit when specifying from, to and interval
     * @summary Premium Index K-line chart
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.from Start time of candlesticks, formatted in Unix timestamp in seconds. Default to&#x60;to - 100 * interval&#x60; if not specified
     * @param opts.to Specify the end time of the K-line chart, defaults to current time if not specified, note that the time format is Unix timestamp with second precision
     * @param opts.limit Maximum number of recent data points to return. &#x60;limit&#x60; conflicts with &#x60;from&#x60; and &#x60;to&#x60;. If either &#x60;from&#x60; or &#x60;to&#x60; is specified, request will be rejected.
     * @param opts.interval Time interval between data points
     */
    public async listFuturesPremiumIndex(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: {
            from?: number;
            to?: number;
            limit?: number;
            interval?: '10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d';
        },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPremiumIndex> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/premium_index'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesPremiumIndex.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listFuturesPremiumIndex.');
        }

        opts = opts || {};
        let contractSerialized = ObjectSerializer.serialize(contract, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(contractSerialized)) {
            contractSerialized = contractSerialized.join(',');
        }
        localVarQueryParameters['contract'] = contractSerialized;

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.interval !== undefined) {
            let intervalSerialized = ObjectSerializer.serialize(
                opts.interval,
                "'10s' | '1m' | '5m' | '15m' | '30m' | '1h' | '4h' | '8h' | '1d' | '7d'",
            );
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(intervalSerialized)) {
                intervalSerialized = intervalSerialized.join(',');
            }
            localVarQueryParameters['interval'] = intervalSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesPremiumIndex>>(config, 'Array<FuturesPremiumIndex>', authSettings);
    }

    /**
     *
     * @summary Get all futures trading statistics
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     */
    public async listFuturesTickers(
        settle: 'btc' | 'usdt',
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesTicker> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/tickers'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesTickers.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesTicker>>(config, 'Array<FuturesTicker>', authSettings);
    }

    /**
     *
     * @summary Futures market historical funding rate
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     */
    public async listFuturesFundingRateHistory(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { limit?: number; from?: number; to?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FundingRateRecord> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/funding_rate'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling listFuturesFundingRateHistory.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling listFuturesFundingRateHistory.',
            );
        }

        opts = opts || {};
        let contractSerialized = ObjectSerializer.serialize(contract, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(contractSerialized)) {
            contractSerialized = contractSerialized.join(',');
        }
        localVarQueryParameters['contract'] = contractSerialized;

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FundingRateRecord>>(config, 'Array<FundingRateRecord>', authSettings);
    }

    /**
     *
     * @summary Futures market insurance fund history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.limit Maximum number of records returned in a single list
     */
    public async listFuturesInsuranceLedger(
        settle: 'btc' | 'usdt',
        opts: { limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<InsuranceRecord> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/insurance'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesInsuranceLedger.');
        }

        opts = opts || {};
        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<InsuranceRecord>>(config, 'Array<InsuranceRecord>', authSettings);
    }

    /**
     *
     * @summary Futures statistics
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.from Start timestamp
     * @param opts.interval
     * @param opts.limit
     */
    public async listContractStats(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { from?: number; interval?: string; limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<ContractStat> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/contract_stats'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listContractStats.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling listContractStats.');
        }

        opts = opts || {};
        let contractSerialized = ObjectSerializer.serialize(contract, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(contractSerialized)) {
            contractSerialized = contractSerialized.join(',');
        }
        localVarQueryParameters['contract'] = contractSerialized;

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.interval !== undefined) {
            let intervalSerialized = ObjectSerializer.serialize(opts.interval, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(intervalSerialized)) {
                intervalSerialized = intervalSerialized.join(',');
            }
            localVarQueryParameters['interval'] = intervalSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<ContractStat>>(config, 'Array<ContractStat>', authSettings);
    }

    /**
     *
     * @summary Query index constituents
     * @param settle Settle currency
     * @param index Index name
     */
    public async getIndexConstituents(
        settle: 'btc' | 'usdt',
        index: string,
    ): Promise<{ response: AxiosResponse; body: FuturesIndexConstituents }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/index_constituents/{index}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'index' + '}', encodeURIComponent(String(index)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getIndexConstituents.');
        }

        // verify required parameter 'index' is not null or undefined
        if (index === null || index === undefined) {
            throw new Error('Required parameter index was null or undefined when calling getIndexConstituents.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<FuturesIndexConstituents>(config, 'FuturesIndexConstituents', authSettings);
    }

    /**
     * The time interval between from and to is maximum 3600. Some private fields are not returned by public interfaces, refer to field descriptions for details
     * @summary Query liquidation order history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.limit Maximum number of records returned in a single list
     */
    public async listLiquidatedOrders(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; from?: number; to?: number; limit?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLiqOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/liq_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listLiquidatedOrders.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesLiqOrder>>(config, 'Array<FuturesLiqOrder>', authSettings);
    }

    /**
     * When the \'contract\' parameter is not passed, the default is to query the risk limits for the top 100 markets. \'Limit\' and \'offset\' correspond to pagination queries at the market level, not to the length of the returned array. This only takes effect when the contract parameter is empty.
     * @summary Query risk limit tiers
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listFuturesRiskLimitTiers(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLimitRiskTiers> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/risk_limit_tiers'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesRiskLimitTiers.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesLimitRiskTiers>>(config, 'Array<FuturesLimitRiskTiers>', authSettings);
    }

    /**
     * Query account information for classic future account and unified account
     * @summary Get futures account
     * @param settle Settle currency
     */
    public async listFuturesAccounts(
        settle: 'btc' | 'usdt',
    ): Promise<{ response: AxiosResponse; body: FuturesAccount }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/accounts'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesAccounts.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesAccount>(config, 'FuturesAccount', authSettings);
    }

    /**
     * If the contract field is passed, only records containing this field after 2023-10-30 can be filtered
     * @summary Query futures account change history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.type Change types:  - dnw: Deposit and withdrawal - pnl: Profit and loss from position reduction - fee: Trading fees - refr: Referrer rebates - fund: Funding fees - point_dnw: Point card deposit and withdrawal - point_fee: Point card trading fees - point_refr: Point card referrer rebates - bonus_offset: Trial fund deduction
     */
    public async listFuturesAccountBook(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; offset?: number; from?: number; to?: number; type?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesAccountBook> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/account_book'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesAccountBook.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        if (opts.type !== undefined) {
            let typeSerialized = ObjectSerializer.serialize(opts.type, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(typeSerialized)) {
                typeSerialized = typeSerialized.join(',');
            }
            localVarQueryParameters['type'] = typeSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesAccountBook>>(config, 'Array<FuturesAccountBook>', authSettings);
    }

    /**
     *
     * @summary Get user position list
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.holding Return only real positions - true, return all - false
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listPositions(
        settle: 'btc' | 'usdt',
        opts: { holding?: boolean; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listPositions.');
        }

        opts = opts || {};
        if (opts.holding !== undefined) {
            let holdingSerialized = ObjectSerializer.serialize(opts.holding, 'boolean');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(holdingSerialized)) {
                holdingSerialized = holdingSerialized.join(',');
            }
            localVarQueryParameters['holding'] = holdingSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     * Get single position information from a contract. If you hold two postions in one contract market, please use this API: /futures/{settle}/dual_comp/positions/{contract}
     * @summary Get single position information
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getPosition(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getPosition.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getPosition.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     * Get Leverage Information for Specified Mode
     * @summary Get Leverage Information for Specified Mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param opts Optional parameters
     * @param opts.posMarginMode Position Margin Mode, required for split position mode, values: isolated/cross.
     * @param opts.dualSide dual_long - Long, dual_short - Short
     */
    public async getLeverage(
        settle: 'btc' | 'usdt',
        contract: string,
        opts: { posMarginMode?: string; dualSide?: string },
    ): Promise<{ response: AxiosResponse; body: FuturesLeverage }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/get_leverage/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getLeverage.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getLeverage.');
        }

        opts = opts || {};
        if (opts.posMarginMode !== undefined) {
            let posMarginModeSerialized = ObjectSerializer.serialize(opts.posMarginMode, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(posMarginModeSerialized)) {
                posMarginModeSerialized = posMarginModeSerialized.join(',');
            }
            localVarQueryParameters['pos_margin_mode'] = posMarginModeSerialized;
        }

        if (opts.dualSide !== undefined) {
            let dualSideSerialized = ObjectSerializer.serialize(opts.dualSide, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(dualSideSerialized)) {
                dualSideSerialized = dualSideSerialized.join(',');
            }
            localVarQueryParameters['dual_side'] = dualSideSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesLeverage>(config, 'FuturesLeverage', authSettings);
    }

    /**
     * Under the new risk limit rules(https://www.gate.com/en/help/futures/futures-logic/22162), the position limit is related to the leverage you set; a lower leverage will result in a higher position limit. Please use the leverage adjustment api to adjust the position limit.
     * @summary Update position margin
     * @param settle Settle currency
     * @param contract Futures contract
     * @param change Margin change amount, positive number increases, negative number decreases
     */
    public async updatePositionMargin(
        settle: 'btc' | 'usdt',
        contract: string,
        change: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/margin'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionMargin.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling updatePositionMargin.');
        }

        // verify required parameter 'change' is not null or undefined
        if (change === null || change === undefined) {
            throw new Error('Required parameter change was null or undefined when calling updatePositionMargin.');
        }

        let changeSerialized = ObjectSerializer.serialize(change, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(changeSerialized)) {
            changeSerialized = changeSerialized.join(',');
        }
        localVarQueryParameters['change'] = changeSerialized;

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *  Position Mode Switching Rules:  - leverage  0: Isolated Margin Mode (Regardless of whether cross_leverage_limit is filled, this parameter will be ignored) - leverage = 0: Cross Margin Mode (Use cross_leverage_limit to set the leverage multiple)  Examples: - Set isolated margin with 10x leverage: leverage=10 - Set cross margin with 10x leverage: leverage=0&cross_leverage_limit=10 - leverage=5&cross_leverage_limit=10  Result: Isolated margin with 5x leverage (cross_leverage_limit is ignored)   Warning: Incorrect settings may cause unexpected position mode switching, affecting risk management.
     * @summary Update position leverage
     * @param settle Settle currency
     * @param contract Futures contract
     * @param leverage Set the leverage for isolated margin. When setting isolated margin leverage, the &#x60;cross_leverage_limit&#x60;  must be empty.
     * @param opts Optional parameters
     * @param opts.crossLeverageLimit Set the leverage for cross margin. When setting cross margin leverage, the &#x60;leverage&#x60; must be set to 0.
     * @param opts.pid Product ID
     */
    public async updatePositionLeverage(
        settle: 'btc' | 'usdt',
        contract: string,
        leverage: string,
        opts: { crossLeverageLimit?: string; pid?: number },
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/leverage'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionLeverage.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling updatePositionLeverage.');
        }

        // verify required parameter 'leverage' is not null or undefined
        if (leverage === null || leverage === undefined) {
            throw new Error('Required parameter leverage was null or undefined when calling updatePositionLeverage.');
        }

        opts = opts || {};
        let leverageSerialized = ObjectSerializer.serialize(leverage, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(leverageSerialized)) {
            leverageSerialized = leverageSerialized.join(',');
        }
        localVarQueryParameters['leverage'] = leverageSerialized;

        if (opts.crossLeverageLimit !== undefined) {
            let crossLeverageLimitSerialized = ObjectSerializer.serialize(opts.crossLeverageLimit, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(crossLeverageLimitSerialized)) {
                crossLeverageLimitSerialized = crossLeverageLimitSerialized.join(',');
            }
            localVarQueryParameters['cross_leverage_limit'] = crossLeverageLimitSerialized;
        }

        if (opts.pid !== undefined) {
            let pidSerialized = ObjectSerializer.serialize(opts.pid, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(pidSerialized)) {
                pidSerialized = pidSerialized.join(',');
            }
            localVarQueryParameters['pid'] = pidSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     * To simplify the complex logic of the leverage interface, added a new interface for modifying leverage
     * @summary Update Leverage for Specified Mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param leverage Position Leverage Multiple
     * @param marginMode Margin Mode isolated/cross
     * @param opts Optional parameters
     * @param opts.dualSide dual_long - Long, dual_short - Short
     */
    public async updateContractPositionLeverage(
        settle: 'btc' | 'usdt',
        contract: string,
        leverage: string,
        marginMode: string,
        opts: { dualSide?: string },
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/set_leverage'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateContractPositionLeverage.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateContractPositionLeverage.',
            );
        }

        // verify required parameter 'leverage' is not null or undefined
        if (leverage === null || leverage === undefined) {
            throw new Error(
                'Required parameter leverage was null or undefined when calling updateContractPositionLeverage.',
            );
        }

        // verify required parameter 'marginMode' is not null or undefined
        if (marginMode === null || marginMode === undefined) {
            throw new Error(
                'Required parameter marginMode was null or undefined when calling updateContractPositionLeverage.',
            );
        }

        opts = opts || {};
        let leverageSerialized = ObjectSerializer.serialize(leverage, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(leverageSerialized)) {
            leverageSerialized = leverageSerialized.join(',');
        }
        localVarQueryParameters['leverage'] = leverageSerialized;

        let marginModeSerialized = ObjectSerializer.serialize(marginMode, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(marginModeSerialized)) {
            marginModeSerialized = marginModeSerialized.join(',');
        }
        localVarQueryParameters['margin_mode'] = marginModeSerialized;

        if (opts.dualSide !== undefined) {
            let dualSideSerialized = ObjectSerializer.serialize(opts.dualSide, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(dualSideSerialized)) {
                dualSideSerialized = dualSideSerialized.join(',');
            }
            localVarQueryParameters['dual_side'] = dualSideSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Switch Position Margin Mode
     * @param settle Settle currency
     * @param futuresPositionCrossMode
     */
    public async updatePositionCrossMode(
        settle: 'btc' | 'usdt',
        futuresPositionCrossMode: FuturesPositionCrossMode,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/cross_mode'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionCrossMode.');
        }

        // verify required parameter 'futuresPositionCrossMode' is not null or undefined
        if (futuresPositionCrossMode === null || futuresPositionCrossMode === undefined) {
            throw new Error(
                'Required parameter futuresPositionCrossMode was null or undefined when calling updatePositionCrossMode.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresPositionCrossMode, 'FuturesPositionCrossMode'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     *
     * @summary Switch Between Cross and Isolated Margin Modes Under Hedge Mode
     * @param settle Settle currency
     * @param inlineObject
     */
    public async updateDualCompPositionCrossMode(
        settle: 'btc' | 'usdt',
        inlineObject: InlineObject,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/cross_mode'.replace(
                '{' + 'settle' + '}',
                encodeURIComponent(String(settle)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualCompPositionCrossMode.',
            );
        }

        // verify required parameter 'inlineObject' is not null or undefined
        if (inlineObject === null || inlineObject === undefined) {
            throw new Error(
                'Required parameter inlineObject was null or undefined when calling updateDualCompPositionCrossMode.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(inlineObject, 'InlineObject'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     * Under the new risk limit rules(https://www.gate.com/en/help/futures/futures-logic/22162), the position limit is related to the leverage you set; a lower leverage will result in a higher position limit. Please use the leverage adjustment api to adjust the position limit.
     * @summary Update position risk limit
     * @param settle Settle currency
     * @param contract Futures contract
     * @param riskLimit New risk limit value
     */
    public async updatePositionRiskLimit(
        settle: 'btc' | 'usdt',
        contract: string,
        riskLimit: string,
    ): Promise<{ response: AxiosResponse; body: Position }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/positions/{contract}/risk_limit'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePositionRiskLimit.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling updatePositionRiskLimit.');
        }

        // verify required parameter 'riskLimit' is not null or undefined
        if (riskLimit === null || riskLimit === undefined) {
            throw new Error('Required parameter riskLimit was null or undefined when calling updatePositionRiskLimit.');
        }

        let riskLimitSerialized = ObjectSerializer.serialize(riskLimit, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(riskLimitSerialized)) {
            riskLimitSerialized = riskLimitSerialized.join(',');
        }
        localVarQueryParameters['risk_limit'] = riskLimitSerialized;

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Position>(config, 'Position', authSettings);
    }

    /**
     * The prerequisite for changing mode is that all positions have no holdings and no pending orders
     * @summary Set position mode
     * @param settle Settle currency
     * @param dualMode Whether to enable Hedge Mode
     */
    public async setDualMode(
        settle: 'btc' | 'usdt',
        dualMode: boolean,
    ): Promise<{ response: AxiosResponse; body: FuturesAccount }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_mode'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling setDualMode.');
        }

        // verify required parameter 'dualMode' is not null or undefined
        if (dualMode === null || dualMode === undefined) {
            throw new Error('Required parameter dualMode was null or undefined when calling setDualMode.');
        }

        let dualModeSerialized = ObjectSerializer.serialize(dualMode, 'boolean');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(dualModeSerialized)) {
            dualModeSerialized = dualModeSerialized.join(',');
        }
        localVarQueryParameters['dual_mode'] = dualModeSerialized;

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesAccount>(config, 'FuturesAccount', authSettings);
    }

    /**
     * The prerequisite for changing mode is that all positions have no holdings and no pending orders
     * @summary Set Position Holding Mode, replacing the dual_mode interface
     * @param settle Settle currency
     * @param positionMode Optional Values: single, dual, dual_plus, representing Single Direction, Dual Direction, Split Position respectively
     */
    public async setPositionMode(
        settle: 'btc' | 'usdt',
        positionMode: string,
    ): Promise<{ response: AxiosResponse; body: FuturesAccount }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/set_position_mode'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling setPositionMode.');
        }

        // verify required parameter 'positionMode' is not null or undefined
        if (positionMode === null || positionMode === undefined) {
            throw new Error('Required parameter positionMode was null or undefined when calling setPositionMode.');
        }

        let positionModeSerialized = ObjectSerializer.serialize(positionMode, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(positionModeSerialized)) {
            positionModeSerialized = positionModeSerialized.join(',');
        }
        localVarQueryParameters['position_mode'] = positionModeSerialized;

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesAccount>(config, 'FuturesAccount', authSettings);
    }

    /**
     *
     * @summary Get position information in Hedge Mode
     * @param settle Settle currency
     * @param contract Futures contract
     */
    public async getDualModePosition(
        settle: 'btc' | 'usdt',
        contract: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getDualModePosition.');
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error('Required parameter contract was null or undefined when calling getDualModePosition.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Update position margin in Hedge Mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param change Margin change amount, positive number increases, negative number decreases
     * @param dualSide Long or short position
     */
    public async updateDualModePositionMargin(
        settle: 'btc' | 'usdt',
        contract: string,
        change: string,
        dualSide: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}/margin'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        // verify required parameter 'change' is not null or undefined
        if (change === null || change === undefined) {
            throw new Error(
                'Required parameter change was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        // verify required parameter 'dualSide' is not null or undefined
        if (dualSide === null || dualSide === undefined) {
            throw new Error(
                'Required parameter dualSide was null or undefined when calling updateDualModePositionMargin.',
            );
        }

        let changeSerialized = ObjectSerializer.serialize(change, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(changeSerialized)) {
            changeSerialized = changeSerialized.join(',');
        }
        localVarQueryParameters['change'] = changeSerialized;

        let dualSideSerialized = ObjectSerializer.serialize(dualSide, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(dualSideSerialized)) {
            dualSideSerialized = dualSideSerialized.join(',');
        }
        localVarQueryParameters['dual_side'] = dualSideSerialized;

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     *
     * @summary Update position leverage in Hedge Mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param leverage New position leverage
     * @param opts Optional parameters
     * @param opts.crossLeverageLimit Cross margin leverage (valid only when &#x60;leverage&#x60; is 0)
     */
    public async updateDualModePositionLeverage(
        settle: 'btc' | 'usdt',
        contract: string,
        leverage: string,
        opts: { crossLeverageLimit?: string },
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}/leverage'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualModePositionLeverage.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDualModePositionLeverage.',
            );
        }

        // verify required parameter 'leverage' is not null or undefined
        if (leverage === null || leverage === undefined) {
            throw new Error(
                'Required parameter leverage was null or undefined when calling updateDualModePositionLeverage.',
            );
        }

        opts = opts || {};
        let leverageSerialized = ObjectSerializer.serialize(leverage, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(leverageSerialized)) {
            leverageSerialized = leverageSerialized.join(',');
        }
        localVarQueryParameters['leverage'] = leverageSerialized;

        if (opts.crossLeverageLimit !== undefined) {
            let crossLeverageLimitSerialized = ObjectSerializer.serialize(opts.crossLeverageLimit, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(crossLeverageLimitSerialized)) {
                crossLeverageLimitSerialized = crossLeverageLimitSerialized.join(',');
            }
            localVarQueryParameters['cross_leverage_limit'] = crossLeverageLimitSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     * Under the new risk limit rules(https://www.gate.com/en/help/futures/futures-logic/22162), the position limit is related to the leverage you set; a lower leverage will result in a higher position limit. Please use the leverage adjustment api to adjust the position limit.
     * @summary Update position risk limit in Hedge Mode
     * @param settle Settle currency
     * @param contract Futures contract
     * @param riskLimit New risk limit value
     */
    public async updateDualModePositionRiskLimit(
        settle: 'btc' | 'usdt',
        contract: string,
        riskLimit: string,
    ): Promise<{ response: AxiosResponse; body: Array<Position> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/dual_comp/positions/{contract}/risk_limit'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'contract' + '}', encodeURIComponent(String(contract)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling updateDualModePositionRiskLimit.',
            );
        }

        // verify required parameter 'contract' is not null or undefined
        if (contract === null || contract === undefined) {
            throw new Error(
                'Required parameter contract was null or undefined when calling updateDualModePositionRiskLimit.',
            );
        }

        // verify required parameter 'riskLimit' is not null or undefined
        if (riskLimit === null || riskLimit === undefined) {
            throw new Error(
                'Required parameter riskLimit was null or undefined when calling updateDualModePositionRiskLimit.',
            );
        }

        let riskLimitSerialized = ObjectSerializer.serialize(riskLimit, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(riskLimitSerialized)) {
            riskLimitSerialized = riskLimitSerialized.join(',');
        }
        localVarQueryParameters['risk_limit'] = riskLimitSerialized;

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<Position>>(config, 'Array<Position>', authSettings);
    }

    /**
     * - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use `GET /futures/{settle}/orders_timerange`.
     * @summary Query futures order list
     * @param settle Settle currency
     * @param status Query order list based on status
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Use the ID of the last record in the previous list as the starting point for the next list  Operations based on custom IDs can only be checked when orders are pending. After orders are completed (filled/cancelled), they can be checked within 1 hour after completion. After expiration, only order IDs can be used
     */
    public async listFuturesOrders(
        settle: 'btc' | 'usdt',
        status: string,
        opts: { contract?: string; limit?: number; offset?: number; lastId?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listFuturesOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listFuturesOrders.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        let statusSerialized = ObjectSerializer.serialize(status, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(statusSerialized)) {
            statusSerialized = statusSerialized.join(',');
        }
        localVarQueryParameters['status'] = statusSerialized;

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        if (opts.lastId !== undefined) {
            let lastIdSerialized = ObjectSerializer.serialize(opts.lastId, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(lastIdSerialized)) {
                lastIdSerialized = lastIdSerialized.join(',');
            }
            localVarQueryParameters['last_id'] = lastIdSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     * - When placing an order, the number of contracts is specified `size`, not the number of coins. The number of coins corresponding to each contract is returned in the contract details interface `quanto_multiplier` - 0 The order that was completed cannot be obtained after 10 minutes of withdrawal, and the order will be mentioned that the order does not exist - Setting `reduce_only` to `true` can prevent the position from being penetrated when reducing the position - In single-position mode, if you need to close the position, you need to set `size` to 0 and `close` to `true` - In dual warehouse mode,   - Reduce position: reduce_only=true, size is a positive number that indicates short position, negative number that indicates long position  - Add number that indicates adding long positions, and negative numbers indicate adding short positions  - Close position: size=0, set the direction of closing position according to auto_size, and set `reduce_only` to true  at the same time - reduce_only: Make sure to only perform position reduction operations to prevent increased positions - Set `stp_act` to determine the use of a strategy that restricts user transactions. For detailed usage, refer to the body parameter `stp_act`
     * @summary Place futures order
     * @param settle Settle currency
     * @param futuresOrder
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async createFuturesOrder(
        settle: 'btc' | 'usdt',
        futuresOrder: FuturesOrder,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createFuturesOrder.');
        }

        // verify required parameter 'futuresOrder' is not null or undefined
        if (futuresOrder === null || futuresOrder === undefined) {
            throw new Error('Required parameter futuresOrder was null or undefined when calling createFuturesOrder.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresOrder, 'FuturesOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     * Zero-fill orders cannot be retrieved 10 minutes after order cancellation
     * @summary Cancel all orders with \'open\' status
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     * @param opts.contract Contract Identifier; if specified, only cancel pending orders related to this contract
     * @param opts.side Specify all buy orders or all sell orders, both are included if not specified. Set to bid to cancel all buy orders, set to ask to cancel all sell orders
     * @param opts.excludeReduceOnly Whether to exclude reduce-only orders
     * @param opts.text Remark for order cancellation
     */
    public async cancelFuturesOrders(
        settle: 'btc' | 'usdt',
        opts: { xGateExptime?: string; contract?: string; side?: string; excludeReduceOnly?: boolean; text?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelFuturesOrders.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.side !== undefined) {
            let sideSerialized = ObjectSerializer.serialize(opts.side, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(sideSerialized)) {
                sideSerialized = sideSerialized.join(',');
            }
            localVarQueryParameters['side'] = sideSerialized;
        }

        if (opts.excludeReduceOnly !== undefined) {
            let excludeReduceOnlySerialized = ObjectSerializer.serialize(opts.excludeReduceOnly, 'boolean');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(excludeReduceOnlySerialized)) {
                excludeReduceOnlySerialized = excludeReduceOnlySerialized.join(',');
            }
            localVarQueryParameters['exclude_reduce_only'] = excludeReduceOnlySerialized;
        }

        if (opts.text !== undefined) {
            let textSerialized = ObjectSerializer.serialize(opts.text, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(textSerialized)) {
                textSerialized = textSerialized.join(',');
            }
            localVarQueryParameters['text'] = textSerialized;
        }

        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     *
     * @summary Query futures order list by time range
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async getOrdersWithTimeRange(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; from?: number; to?: number; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders_timerange'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getOrdersWithTimeRange.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesOrder>>(config, 'Array<FuturesOrder>', authSettings);
    }

    /**
     * - Up to 10 orders per request - If any of the order\'s parameters are missing or in the wrong format, all of them will not be executed, and a http status 400 error will be returned directly - If the parameters are checked and passed, all are executed. Even if there is a business logic error in the middle (such as insufficient funds), it will not affect other execution orders - The returned result is in array format, and the order corresponds to the orders in the request body - In the returned result, the `succeeded` field of type bool indicates whether the execution was successful or not - If the execution is successful, the normal order content is included; if the execution fails, the `label` field is included to indicate the cause of the error - In the rate limiting, each order is counted individually
     * @summary Place batch futures orders
     * @param settle Settle currency
     * @param futuresOrder
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async createBatchFuturesOrder(
        settle: 'btc' | 'usdt',
        futuresOrder: Array<FuturesOrder>,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Array<BatchFuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/batch_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createBatchFuturesOrder.');
        }

        // verify required parameter 'futuresOrder' is not null or undefined
        if (futuresOrder === null || futuresOrder === undefined) {
            throw new Error(
                'Required parameter futuresOrder was null or undefined when calling createBatchFuturesOrder.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresOrder, 'Array<FuturesOrder>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<BatchFuturesOrder>>(config, 'Array<BatchFuturesOrder>', authSettings);
    }

    /**
     * - Zero-fill order cannot be retrieved for 10 minutes after cancellation - Historical orders, by default, only data within the past 6 months is supported.
     * @summary Query single order details
     * @param settle Settle currency
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted.
     */
    public async getFuturesOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getFuturesOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getFuturesOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     *
     * @summary Amend single order
     * @param settle Settle currency
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted.
     * @param futuresOrderAmendment
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async amendFuturesOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
        futuresOrderAmendment: FuturesOrderAmendment,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling amendFuturesOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling amendFuturesOrder.');
        }

        // verify required parameter 'futuresOrderAmendment' is not null or undefined
        if (futuresOrderAmendment === null || futuresOrderAmendment === undefined) {
            throw new Error(
                'Required parameter futuresOrderAmendment was null or undefined when calling amendFuturesOrder.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresOrderAmendment, 'FuturesOrderAmendment'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     *
     * @summary Cancel single order
     * @param settle Settle currency
     * @param orderId Order ID returned, or user custom ID(i.e., &#x60;text&#x60; field). Operations based on custom ID can only be checked when the order is in orderbook. finished, it can be checked within 60 seconds after the end of the order. After that, only order ID is accepted.
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async cancelFuturesOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelFuturesOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelFuturesOrder.');
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     * By default, only data within the past 6 months is supported.  If you need to query data for a longer period, please use `GET /futures/{settle}/my_trades_timerange`.
     * @summary Query personal trading records
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.order Futures order ID, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.lastId Specify the starting point for this list based on a previously retrieved id  This parameter is deprecated. If you need to iterate through and retrieve more records, we recommend using \&#39;GET /futures/{settle}/my_trades_timerange\&#39;.
     */
    public async getMyTrades(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; order?: number; limit?: number; offset?: number; lastId?: string },
    ): Promise<{ response: AxiosResponse; body: Array<MyFuturesTrade> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/my_trades'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getMyTrades.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.order !== undefined) {
            let orderSerialized = ObjectSerializer.serialize(opts.order, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(orderSerialized)) {
                orderSerialized = orderSerialized.join(',');
            }
            localVarQueryParameters['order'] = orderSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        if (opts.lastId !== undefined) {
            let lastIdSerialized = ObjectSerializer.serialize(opts.lastId, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(lastIdSerialized)) {
                lastIdSerialized = lastIdSerialized.join(',');
            }
            localVarQueryParameters['last_id'] = lastIdSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<MyFuturesTrade>>(config, 'Array<MyFuturesTrade>', authSettings);
    }

    /**
     *
     * @summary Query personal trading records by time range
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.role Query role, maker or taker
     */
    public async getMyTradesWithTimeRange(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; from?: number; to?: number; limit?: number; offset?: number; role?: string },
    ): Promise<{ response: AxiosResponse; body: Array<MyFuturesTradeTimeRange> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/my_trades_timerange'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getMyTradesWithTimeRange.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        if (opts.role !== undefined) {
            let roleSerialized = ObjectSerializer.serialize(opts.role, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(roleSerialized)) {
                roleSerialized = roleSerialized.join(',');
            }
            localVarQueryParameters['role'] = roleSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<MyFuturesTradeTimeRange>>(
            config,
            'Array<MyFuturesTradeTimeRange>',
            authSettings,
        );
    }

    /**
     *
     * @summary Query position close history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.side Query side. long or shot
     * @param opts.pnl Query profit or loss
     */
    public async listPositionClose(
        settle: 'btc' | 'usdt',
        opts: {
            contract?: string;
            limit?: number;
            offset?: number;
            from?: number;
            to?: number;
            side?: string;
            pnl?: string;
        },
    ): Promise<{ response: AxiosResponse; body: Array<PositionClose> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/position_close'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listPositionClose.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        if (opts.side !== undefined) {
            let sideSerialized = ObjectSerializer.serialize(opts.side, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(sideSerialized)) {
                sideSerialized = sideSerialized.join(',');
            }
            localVarQueryParameters['side'] = sideSerialized;
        }

        if (opts.pnl !== undefined) {
            let pnlSerialized = ObjectSerializer.serialize(opts.pnl, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(pnlSerialized)) {
                pnlSerialized = pnlSerialized.join(',');
            }
            localVarQueryParameters['pnl'] = pnlSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<PositionClose>>(config, 'Array<PositionClose>', authSettings);
    }

    /**
     *
     * @summary Query liquidation history
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.at Specify liquidation timestamp
     */
    public async listLiquidates(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; offset?: number; from?: number; to?: number; at?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesLiquidate> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/liquidates'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listLiquidates.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        if (opts.at !== undefined) {
            let atSerialized = ObjectSerializer.serialize(opts.at, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(atSerialized)) {
                atSerialized = atSerialized.join(',');
            }
            localVarQueryParameters['at'] = atSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesLiquidate>>(config, 'Array<FuturesLiquidate>', authSettings);
    }

    /**
     *
     * @summary Query ADL auto-deleveraging order information
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     * @param opts.from Start timestamp  Specify start time, time format is Unix timestamp. If not specified, it defaults to (the data start time of the time range actually returned by to and limit)
     * @param opts.to Termination Timestamp  Specify the end time. If not specified, it defaults to the current time, and the time format is a Unix timestamp
     * @param opts.at Specify auto-deleveraging timestamp
     */
    public async listAutoDeleverages(
        settle: 'btc' | 'usdt',
        opts: { contract?: string; limit?: number; offset?: number; from?: number; to?: number; at?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesAutoDeleverage> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/auto_deleverages'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listAutoDeleverages.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        if (opts.from !== undefined) {
            let fromSerialized = ObjectSerializer.serialize(opts.from, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(fromSerialized)) {
                fromSerialized = fromSerialized.join(',');
            }
            localVarQueryParameters['from'] = fromSerialized;
        }

        if (opts.to !== undefined) {
            let toSerialized = ObjectSerializer.serialize(opts.to, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(toSerialized)) {
                toSerialized = toSerialized.join(',');
            }
            localVarQueryParameters['to'] = toSerialized;
        }

        if (opts.at !== undefined) {
            let atSerialized = ObjectSerializer.serialize(opts.at, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(atSerialized)) {
                atSerialized = atSerialized.join(',');
            }
            localVarQueryParameters['at'] = atSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesAutoDeleverage>>(config, 'Array<FuturesAutoDeleverage>', authSettings);
    }

    /**
     * Heartbeat detection for contract orders: When the user-set `timeout` time is reached, if neither the existing countdown is canceled nor a new countdown is set, the relevant contract orders will be automatically canceled. This API can be called repeatedly to or cancel the countdown. Usage example: Repeatedly call this API at 30-second intervals, setting the `timeout` to 30 (seconds) each time. If this API is not called again within 30 seconds, all open orders on your specified `market` will be automatically canceled. If the `timeout` is set to 0 within 30 seconds, the countdown timer will terminate, and the automatic order cancellation function will be disabled.
     * @summary Countdown cancel orders
     * @param settle Settle currency
     * @param countdownCancelAllFuturesTask
     */
    public async countdownCancelAllFutures(
        settle: 'btc' | 'usdt',
        countdownCancelAllFuturesTask: CountdownCancelAllFuturesTask,
    ): Promise<{ response: AxiosResponse; body: TriggerTime }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/countdown_cancel_all'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling countdownCancelAllFutures.');
        }

        // verify required parameter 'countdownCancelAllFuturesTask' is not null or undefined
        if (countdownCancelAllFuturesTask === null || countdownCancelAllFuturesTask === undefined) {
            throw new Error(
                'Required parameter countdownCancelAllFuturesTask was null or undefined when calling countdownCancelAllFutures.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(countdownCancelAllFuturesTask, 'CountdownCancelAllFuturesTask'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerTime>(config, 'TriggerTime', authSettings);
    }

    /**
     *
     * @summary Query futures market trading fee rates
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     */
    public async getFuturesFee(
        settle: 'btc' | 'usdt',
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: { [key: string]: FuturesFee } }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/fee'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getFuturesFee.');
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<{ [key: string]: FuturesFee }>(
            config,
            '{ [key: string]: FuturesFee; }',
            authSettings,
        );
    }

    /**
     * Multiple different order IDs can be specified. A maximum of 20 records can be cancelled in one request
     * @summary Cancel batch orders by specified ID list
     * @param settle Settle currency
     * @param requestBody
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async cancelBatchFutureOrders(
        settle: 'btc' | 'usdt',
        requestBody: Array<string>,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FutureCancelOrderResult> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/batch_cancel_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelBatchFutureOrders.');
        }

        // verify required parameter 'requestBody' is not null or undefined
        if (requestBody === null || requestBody === undefined) {
            throw new Error(
                'Required parameter requestBody was null or undefined when calling cancelBatchFutureOrders.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(requestBody, 'Array<string>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FutureCancelOrderResult>>(
            config,
            'Array<FutureCancelOrderResult>',
            authSettings,
        );
    }

    /**
     * Multiple different order IDs can be specified. A maximum of 10 orders can be modified in one request
     * @summary Batch modify orders by specified IDs
     * @param settle Settle currency
     * @param batchAmendOrderReq
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async amendBatchFutureOrders(
        settle: 'btc' | 'usdt',
        batchAmendOrderReq: Array<BatchAmendOrderReq>,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: Array<BatchFuturesOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/batch_amend_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling amendBatchFutureOrders.');
        }

        // verify required parameter 'batchAmendOrderReq' is not null or undefined
        if (batchAmendOrderReq === null || batchAmendOrderReq === undefined) {
            throw new Error(
                'Required parameter batchAmendOrderReq was null or undefined when calling amendBatchFutureOrders.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(batchAmendOrderReq, 'Array<BatchAmendOrderReq>'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<BatchFuturesOrder>>(config, 'Array<BatchFuturesOrder>', authSettings);
    }

    /**
     * Just pass table_id
     * @summary Query risk limit table by table_id
     * @param settle Settle currency
     * @param tableId Risk limit table ID
     */
    public async getFuturesRiskLimitTable(
        settle: 'btc' | 'usdt',
        tableId: string,
    ): Promise<{ response: AxiosResponse; body: Array<FuturesRiskLimitTier> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/risk_limit_table'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getFuturesRiskLimitTable.');
        }

        // verify required parameter 'tableId' is not null or undefined
        if (tableId === null || tableId === undefined) {
            throw new Error('Required parameter tableId was null or undefined when calling getFuturesRiskLimitTable.');
        }

        let tableIdSerialized = ObjectSerializer.serialize(tableId, 'string');
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(tableIdSerialized)) {
            tableIdSerialized = tableIdSerialized.join(',');
        }
        localVarQueryParameters['table_id'] = tableIdSerialized;

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = [];
        return this.client.request<Array<FuturesRiskLimitTier>>(config, 'Array<FuturesRiskLimitTier>', authSettings);
    }

    /**
     * Compared to the futures trading order placement interface (futures/{settle}/orders), it adds the `level` and `direction` parameters.
     * @summary Level-based BBO Contract Order Placement
     * @param settle Settle currency
     * @param futuresBBOOrder
     * @param opts Optional parameters
     * @param opts.xGateExptime Specify the expiration time (milliseconds); if the GATE receives the request time greater than the expiration time, the request will be rejected
     */
    public async createFuturesBBOOrder(
        settle: 'btc' | 'usdt',
        futuresBBOOrder: FuturesBBOOrder,
        opts: { xGateExptime?: string },
    ): Promise<{ response: AxiosResponse; body: FuturesOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/bbo_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createFuturesBBOOrder.');
        }

        // verify required parameter 'futuresBBOOrder' is not null or undefined
        if (futuresBBOOrder === null || futuresBBOOrder === undefined) {
            throw new Error(
                'Required parameter futuresBBOOrder was null or undefined when calling createFuturesBBOOrder.',
            );
        }

        opts = opts || {};
        if (opts.xGateExptime !== undefined) {
            localVarHeaderParams['x-gate-exptime'] = ObjectSerializer.serialize(opts.xGateExptime, 'string');
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresBBOOrder, 'FuturesBBOOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesOrder>(config, 'FuturesOrder', authSettings);
    }

    /**
     *
     * @summary Query auto order list
     * @param settle Settle currency
     * @param status Query order list based on status
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     * @param opts.limit Maximum number of records returned in a single list
     * @param opts.offset List offset, starting from 0
     */
    public async listPriceTriggeredOrders(
        settle: 'btc' | 'usdt',
        status: 'open' | 'finished',
        opts: { contract?: string; limit?: number; offset?: number },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPriceTriggeredOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling listPriceTriggeredOrders.');
        }

        // verify required parameter 'status' is not null or undefined
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling listPriceTriggeredOrders.');
        }

        opts = opts || {};
        let statusSerialized = ObjectSerializer.serialize(status, "'open' | 'finished'");
        // For array query parameters with style:form and explode:false, convert to comma-separated string
        if (Array.isArray(statusSerialized)) {
            statusSerialized = statusSerialized.join(',');
        }
        localVarQueryParameters['status'] = statusSerialized;

        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        if (opts.limit !== undefined) {
            let limitSerialized = ObjectSerializer.serialize(opts.limit, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(limitSerialized)) {
                limitSerialized = limitSerialized.join(',');
            }
            localVarQueryParameters['limit'] = limitSerialized;
        }

        if (opts.offset !== undefined) {
            let offsetSerialized = ObjectSerializer.serialize(opts.offset, 'number');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(offsetSerialized)) {
                offsetSerialized = offsetSerialized.join(',');
            }
            localVarQueryParameters['offset'] = offsetSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesPriceTriggeredOrder>>(
            config,
            'Array<FuturesPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Create price-triggered order
     * @param settle Settle currency
     * @param futuresPriceTriggeredOrder
     */
    public async createPriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        futuresPriceTriggeredOrder: FuturesPriceTriggeredOrder,
    ): Promise<{ response: AxiosResponse; body: TriggerOrderResponse }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling createPriceTriggeredOrder.');
        }

        // verify required parameter 'futuresPriceTriggeredOrder' is not null or undefined
        if (futuresPriceTriggeredOrder === null || futuresPriceTriggeredOrder === undefined) {
            throw new Error(
                'Required parameter futuresPriceTriggeredOrder was null or undefined when calling createPriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresPriceTriggeredOrder, 'FuturesPriceTriggeredOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerOrderResponse>(config, 'TriggerOrderResponse', authSettings);
    }

    /**
     *
     * @summary Cancel all auto orders
     * @param settle Settle currency
     * @param opts Optional parameters
     * @param opts.contract Futures contract, return related data only if specified
     */
    public async cancelPriceTriggeredOrderList(
        settle: 'btc' | 'usdt',
        opts: { contract?: string },
    ): Promise<{ response: AxiosResponse; body: Array<FuturesPriceTriggeredOrder> }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders'.replace('{' + 'settle' + '}', encodeURIComponent(String(settle)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error(
                'Required parameter settle was null or undefined when calling cancelPriceTriggeredOrderList.',
            );
        }

        opts = opts || {};
        if (opts.contract !== undefined) {
            let contractSerialized = ObjectSerializer.serialize(opts.contract, 'string');
            // For array query parameters with style:form and explode:false, convert to comma-separated string
            if (Array.isArray(contractSerialized)) {
                contractSerialized = contractSerialized.join(',');
            }
            localVarQueryParameters['contract'] = contractSerialized;
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<Array<FuturesPriceTriggeredOrder>>(
            config,
            'Array<FuturesPriceTriggeredOrder>',
            authSettings,
        );
    }

    /**
     *
     * @summary Query single auto order details
     * @param settle Settle currency
     * @param orderId ID returned when order is successfully created
     */
    public async getPriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling getPriceTriggeredOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling getPriceTriggeredOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesPriceTriggeredOrder>(config, 'FuturesPriceTriggeredOrder', authSettings);
    }

    /**
     *
     * @summary Modify a Single Auto Order
     * @param settle Settle currency
     * @param orderId ID returned when order is successfully created
     * @param futuresUpdatePriceTriggeredOrder
     */
    public async updatePriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
        futuresUpdatePriceTriggeredOrder: FuturesUpdatePriceTriggeredOrder,
    ): Promise<{ response: AxiosResponse; body: TriggerOrderResponse }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling updatePriceTriggeredOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling updatePriceTriggeredOrder.');
        }

        // verify required parameter 'futuresUpdatePriceTriggeredOrder' is not null or undefined
        if (futuresUpdatePriceTriggeredOrder === null || futuresUpdatePriceTriggeredOrder === undefined) {
            throw new Error(
                'Required parameter futuresUpdatePriceTriggeredOrder was null or undefined when calling updatePriceTriggeredOrder.',
            );
        }

        const config: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            data: ObjectSerializer.serialize(futuresUpdatePriceTriggeredOrder, 'FuturesUpdatePriceTriggeredOrder'),
        };

        const authSettings = ['apiv4'];
        return this.client.request<TriggerOrderResponse>(config, 'TriggerOrderResponse', authSettings);
    }

    /**
     *
     * @summary Cancel single auto order
     * @param settle Settle currency
     * @param orderId ID returned when order is successfully created
     */
    public async cancelPriceTriggeredOrder(
        settle: 'btc' | 'usdt',
        orderId: string,
    ): Promise<{ response: AxiosResponse; body: FuturesPriceTriggeredOrder }> {
        const localVarPath =
            this.client.basePath +
            '/futures/{settle}/price_orders/{order_id}'
                .replace('{' + 'settle' + '}', encodeURIComponent(String(settle)))
                .replace('{' + 'order_id' + '}', encodeURIComponent(String(orderId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.client.defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }

        // verify required parameter 'settle' is not null or undefined
        if (settle === null || settle === undefined) {
            throw new Error('Required parameter settle was null or undefined when calling cancelPriceTriggeredOrder.');
        }

        // verify required parameter 'orderId' is not null or undefined
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling cancelPriceTriggeredOrder.');
        }

        const config: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
        };

        const authSettings = ['apiv4'];
        return this.client.request<FuturesPriceTriggeredOrder>(config, 'FuturesPriceTriggeredOrder', authSettings);
    }
}
